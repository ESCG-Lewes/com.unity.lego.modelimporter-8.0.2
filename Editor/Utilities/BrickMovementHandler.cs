// Copyright (C) LEGO System A/S - All Rights Reserved
// Unauthorized copying of this file, via any medium is strictly prohibited
// Place this file in: Editor/Utilities/BrickMovementHandler.cs

using UnityEngine;
using UnityEditor;
using System.Collections.Generic;

namespace LEGOModelImporter
{
    /// <summary>
    /// Monitors brick movements and automatically decouples them when Lock Bricks After Placement is disabled
    /// </summary>
    [InitializeOnLoad]
    public static class BrickMovementHandler
    {
        private static Dictionary<Brick, Vector3> brickLastPositions = new Dictionary<Brick, Vector3>();
        private static Dictionary<Brick, bool> brickWasSelected = new Dictionary<Brick, bool>();
        private static bool isInitialized = false;

        static BrickMovementHandler()
        {
            EditorApplication.update += OnEditorUpdate;
            Selection.selectionChanged += OnSelectionChanged;
            ToolsSettings.lockBricksAfterPlacementChanged += OnLockSettingChanged;
            isInitialized = true;
        }

        private static void OnEditorUpdate()
        {
            if (EditorApplication.isPlaying) return;
            if (!ToolsSettings.IsBrickBuildingOn) return;

            // Safety check for SceneView
            if (SceneView.lastActiveSceneView == null) return;

            // Clean up null entries
            var keysToRemove = new List<Brick>();
            foreach (var kvp in brickLastPositions)
            {
                if (kvp.Key == null)
                {
                    keysToRemove.Add(kvp.Key);
                }
            }
            foreach (var key in keysToRemove)
            {
                brickLastPositions.Remove(key);
                brickWasSelected.Remove(key);
            }
        }

        private static void OnSelectionChanged()
        {
            if (EditorApplication.isPlaying) return;
            if (!ToolsSettings.IsBrickBuildingOn) return;

            // Safety check
            if (Selection.gameObjects == null) return;

            // Check previously selected bricks that are now deselected
            var bricksToCheck = new List<Brick>();
            foreach (var kvp in brickWasSelected)
            {
                if (kvp.Value && kvp.Key != null)
                {
                    // This brick was selected, check if it's still selected
                    bool stillSelected = System.Array.Exists(Selection.gameObjects, go => 
                        go != null && (go == kvp.Key.gameObject || go.GetComponent<Brick>() == kvp.Key));
                    
                    if (!stillSelected)
                    {
                        bricksToCheck.Add(kvp.Key);
                    }
                }
            }

            // Update selection status for all bricks
            brickWasSelected.Clear();
            foreach (var go in Selection.gameObjects)
            {
                if (go != null)
                {
                    var brick = go.GetComponent<Brick>();
                    if (brick != null)
                    {
                        brickWasSelected[brick] = true;
                        // Store initial position when selected
                        if (!brickLastPositions.ContainsKey(brick))
                        {
                            brickLastPositions[brick] = brick.transform.position;
                        }
                    }
                }
            }

            // Process deselected bricks
            foreach (var brick in bricksToCheck)
            {
                HandleBrickDeselection(brick);
            }
        }

        private static void HandleBrickDeselection(Brick brick)
        {
            if (brick == null) return;
            if (ToolsSettings.LockBricksAfterPlacement) return;

            // Check if brick has moved
            if (brickLastPositions.TryGetValue(brick, out Vector3 lastPosition))
            {
                float distanceMoved = Vector3.Distance(brick.transform.position, lastPosition);
                
                // If brick moved more than a small threshold, decouple it
                if (distanceMoved > 0.01f)
                {
                    var modelGroup = brick.GetComponentInParent<ModelGroup>();
                    if (modelGroup != null && !modelGroup.autoGenerated)
                    {
                        // Only decouple if it's part of a non-auto-generated group
                        if (BrickDecoupler.CanDecoupleBrick(brick))
                        {
                            Debug.Log($"Brick {brick.designID} moved {distanceMoved} units - decoupling from {modelGroup.groupName}");
                            BrickDecoupler.DecoupleBrick(brick);
                        }
                    }
                }
                
                // Clean up
                brickLastPositions.Remove(brick);
            }
        }

        private static void OnLockSettingChanged(bool isLocked)
        {
            if (isLocked)
            {
                // Clear tracking when locking is enabled
                brickLastPositions.Clear();
                brickWasSelected.Clear();
            }
        }
    }
}